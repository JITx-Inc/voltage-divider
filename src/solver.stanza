#use-added-syntax(jitx)
defpackage voltage-divider/solver:
  import core
  import collections
  import json

  import jitx with :
    prefix(Resistor) => EModel-
    prefix(Capacitor) => EModel-
    prefix(Inductor) => EModel-
  import jitx/commands

  import jitx/parts/query-api
  import jitx/parts/legacy-ocdb-structures

  import jsl/ensure
  import jsl/errors
  import jsl/design/settings

  import voltage-divider/errors

doc: \<DOC>
Standard Precision Values

This is the default set of precisions that will
be searched to satisfy a set of voltage divider constraints
<DOC>
public val std-precs = [(20 %), (10 %), (5 %), (2 %), (1 %), (0.5 %), (0.25 %), (0.1 %)]

doc: \<DOC>
Voltage Divider Solution Type
<DOC>
public defstruct VoltageDividerSolution :
  doc: \<DOC>
  High Resistor in the voltage divider circuit configuration
  <DOC>
  r1: Resistor
  doc: \<DOC>
  Low Resistor in the voltage divider circuit configuration
  <DOC>
  r2: Resistor
  doc: \<DOC>
  Output Voltage Range
  This voltage is computed over the precision and the variation
  of this resistor in temperature over the operating temperature
  range.
  <DOC>
  vo: Toleranced

doc: \<DOC>
Internal Result Type Primarily to support Sorting
<DOC>
defstruct Ratio :
  doc: \<DOC>
  High Side Divider Resistor Value in Ohms
  This value is assumed to be from a particular precision
  series as defined in the algorithm below.
  <DOC>
  high: Double with:
    ensure => ensure-positive!
  doc: \<DOC>
  Low Side Divider Resistor Value in Ohms
  This value is assumed to be from a particular precision
  series as defined in the algorithm below.
  <DOC>
  low: Double with:
    ensure => ensure-positive!
  doc: \<DOC>
  Loss Metric Used for Sorting which `Ratio` values to use in ultimate solution.
  <DOC>
  loss: Double with:
    ensure => ensure-positive!

val DEF_MIN_SRCS = 3
val DEF_QUERY_LIMIT = 50
val DEF_SEARCH_RANGE = (10 %)

doc: \<DOC>
Voltage Divider Constraints

This type encapsulates the necessary parameters for the
solver as well as other logistics parameters
for the generated result.
<DOC>
public defstruct VoltageDividerConstraints:
  doc: \<DOC>
  Input Voltage Range
  This parameter encodes the typical DC voltage
  range for the input.
  <DOC>
  v-in:Toleranced
  doc: \<DOC>
  Desired Voltage Output Range
  Construct a voltage divider such that the specified
  input voltage results in a output voltage in this range.
  <DOC>
  v-out:Toleranced
  doc: \<DOC>
  Max current in amps allowed through the divider
  <DOC>
  current:Double with:
    ensure => ensure-positive!

  doc: \<DOC>
  Set of precision series to search
  By default, we search the following series:
    [(20 %), (10 %), (5 %), (2 %), (1 %), (0.5 %), (0.25 %), (0.1 %)]
  The user can customize this series by pass an overriding series.
  <DOC>
  prec-series:Tuple<Percentage> with:
    default => std-precs

  doc: \<DOC>
  Set the search range for components to select
  This algorithm does a pre-screening of resistor values based on
  the `v-in`, `v-out`, and `current` parameters. Then this
  parameter limits how far from these pre-screen values we're willing
  to search to find an acceptable solution.
  <DOC>
  search-range:Percentage with:
    ensure => ensure-positive!
    default => DEF_SEARCH_RANGE
  doc: \<DOC>
  Set the minimum number of sources

  When pulling resistors from the database, this algorithm will
  limit the selection of resistors to only those components
  for which there are at least `min-sources` number of manufacturers
  for comparable parts.
  By default this value is 3.
  <DOC>
  min-sources:Int with:
    ensure => ensure-positive!
    default => DEF_MIN_SRCS
  doc: \<DOC>
  Query Limiter for Results

  For many resistors, there may be 1000's of parts that
  match a particular query. This parameter limits the
  number of returned results to some max so as not to
  overload the parts database. The default value is 50.
  This value must be greater than the `min-sources`
  parameter.
  <DOC>
  query-limit:Int with:
    ensure => ensure-positive!
    default => DEF_QUERY_LIMIT

  doc: \<DOC>
  Temperature Range for TCR evaluation.
  By default this value will use the `OPERATING-TEMPERATURE`
  specified in the JSL design settings.
  <DOC>
  temp-range:Toleranced with:
    default => OPERATING-TEMPERATURE
  doc: \<DOC>
  Base ResistorQuery

  This object allows the user to further fine tune the
  selected resistors as part of the solver. The global
  design level defaults will still apply but this can
  be used to override or add to the query parameters.
  Avoid specifying the `resistance`, `tolerance`, or
  `precision` values in this base query builder.
  <DOC>
  base-query:ResistorQuery with:
    default => ResistorQuery()
with:
  constructor => #VoltageDividerConstraints

doc: \<DOC>
Compute the output objective voltage range as a Toleranced based on resistor features.

This function is expected to be implemented by derived `VoltageDividerConstraints` object.
This function is compute the objective of the solver and must match with the
implementations of `is-compliant?` and `compute-loss`.

@param cxt Self
@param rh The top resistor in the divider.
@param rl The bottom resistor in the divider.
@param hi-dr Delta-Resistance as a Toleranced with a nominal value of 1.0. This value when multiplied
against the nominal `hi` resistance value gives the range of resistances expected for the operating
temperature range. The implementation will typically define a default of `typ(1.0)`.
@param lo-dr Delta-Resistance as a Toleranced with a nominal value of 1.0. This value when multiplied
against the nominal `lo` resistance value gives the range of resistances expected for the operating
temperature range. The implementation will typically define a default of `typ(1.0)`.
<DOC>
public defmulti compute-objective (
  cxt:VoltageDividerConstraints,
  rh:Toleranced,
  rl:Toleranced,
  lo-dr:Toleranced = ?,
  hi-dr:Toleranced = ?
  ) -> Toleranced

doc: \<DOC>
Default `compute-objective`

This function currently computes the objective as the forward voltage of the
voltage divider. Meaning the middle node of the divider is the output.

```
Vobj = V-in * (R-L / (R-H + R-L))
```

<DOC>
public defmethod compute-objective (
  cxt:VoltageDividerConstraints,
  rh:Toleranced,
  rl:Toleranced,
  hi-dr:Toleranced = tol(1.0)
  lo-dr:Toleranced = tol(1.0),
  ) -> Toleranced:
  val r-hi = rh * hi-dr
  val r-lo = rl * lo-dr

  val vout = v-in(cxt) * r-lo / (r-lo + r-hi)
  ; println("Computed: r-lo=%_ r-hi=%_ vin=%_ -- vout = %_" % [r-lo, r-hi, v-in(cxt), vout])
  vout

doc: \<DOC>
Check if the computed objective voltage is within the user-defined constraints

This function must be consistent with the `compute-objective` and `compute-loss`

@param cxt Self
@param vout Output Objective of the solver. This may be the input or output voltage
depending on how the solver is being used.
<DOC>
public defmulti is-compliant? (cxt:VoltageDividerConstraints, v-obj:Toleranced|Double) -> True|False

public defmethod is-compliant? (cxt:VoltageDividerConstraints, v-obj:Toleranced|Double) -> True|False :
  in-range?(v-out(cxt), v-obj)


doc: \<DOC>
Compute a loss function for a potential solution.

This function is expected to compute a positive value indicating
how much error this particular R-hi and R-lo combination will contribute
to the resulting objective solution.

@return Positive value if not None(). A value closer to 0 indicates that the solution is better. A value of
0.0 indicates a perfect solution.
If None() this an indication that the provided ratio is not a solution and should not be considered
<DOC>
public defmulti compute-loss (cxt:VoltageDividerConstraints, rh:Double, rl:Double, precision:Percentage) -> Maybe<Double>

public defmethod compute-loss (cxt:VoltageDividerConstraints, rh:Double, rl:Double, precision:Percentage) -> Maybe<Double>:
  val vo = compute-objective(cxt,
    rh +/- precision
    rl +/- precision,
  )
  if is-compliant?(cxt, vo):
    ; This metric is suspect
    ;  - It does not consider the span of the output
    ;     For example - you could have two configurations:
    ;       1.  2.5 +/- 0.1
    ;       2.  2.499 +/- 0.01
    ;    If the target was 2.5 - then the first would have lower
    ;    loss but would not be preferred.
    One $ abs(typ-value(v-out(cxt)) - typ-value(vo))
  else :
    None()

public defmulti compute-initial-guess (cxt:VoltageDividerConstraints) -> [Double, Double]

public defmethod compute-initial-guess (cxt:VoltageDividerConstraints) -> [Double, Double]:
  val r-hi = (typ(v-in(cxt)) - typ(v-out(cxt))) / current(cxt)
  val r-lo = typ(v-out(cxt)) / current(cxt)
  [r-hi, r-lo]


public defn VoltageDividerConstraints (
  --
  v-in:Toleranced,
  v-out:Toleranced,
  current:Double,
  prec-series:Collection<Percentage> = std-precs,
  search-range:Percentage = DEF_SEARCH_RANGE
  min-sources:Int = DEF_MIN_SRCS,
  query-limit:Int = DEF_QUERY_LIMIT
  temp-range:Toleranced = OPERATING-TEMPERATURE
  base-query:ResistorQuery = ResistorQuery()
  ) -> VoltageDividerConstraints:

  val series = to-vector<Percentage>(prec-series)
  qsort!(series)
  ; Sort in Descending order
  reverse!(series)

  if min-sources > query-limit:
    throw $ ValueError(
      "Min Sources must be less than Query Limit: min-sources=%_ query-limit=%_" % [min-sources, query-limit]
    )

  #VoltageDividerConstraints(
    v-in, v-out, current,
    to-tuple(series), search-range, min-sources, query-limit,
    temp-range, base-query
  )

public defn solve (cxt:VoltageDividerConstraints) -> VoltageDividerSolution :

  ; This sets the range of values that we consider. Currently,
  ; We use the maximum precision value to set our
  ;  search distance.
  val search-prec = search-range(cxt)

  val [goal-r-hi, goal-r-lo] = compute-initial-guess(cxt)

  ; Run an initial filter on precision series to remove any
  ;  precision values that will obviously not work.
  ; NOTE - `prec-series` is expected to be sorted in
  ;  descending order
  val first-valid-series = for std-prec in prec-series(cxt) index-when :
    val vo = compute-objective(cxt,
        goal-r-hi +/- std-prec
        goal-r-lo +/- std-prec
      )
    is-compliant?(cxt, vo)

  val series = match(first-valid-series:Int):
    prec-series(cxt)[first-valid-series to false]
  else:
    throw $ NoSolutionFoundError("No Precision Series can satisfy initial constraints")

  ; println("Valid Precision Series: %_" % [series])
  val sol? = for std-prec in series first:
    println("-> Precision %_" % [std-prec])
    solve-over-series(cxt, std-prec, search-prec)

  match(sol?):
    (sol:One<VoltageDividerSolution>): value(sol)
    (sol):
      throw $ NoSolutionFoundError("Failed to Source Resistors to Satisfy Voltage Divider Constraints")


doc: \<DOC>
Solve for the Voltage Divider over a particular Precision Series
@param cxt Voltage Divider Constraints
@param precision Series precision for which we will search
@param search-prec Range over which we will accept resistors. This
sets the +/- percentage range over which we will search for resistors
that are similar to the goal resistor values.
<DOC>
public defn solve-over-series (
  cxt:VoltageDividerConstraints,
  precision: Percentage,
  search-prec: Percentage) -> Maybe<VoltageDividerSolution> :

  val [goal-r-hi, goal-r-lo] = compute-initial-guess(cxt)

  ; Find best resistors matching output requirement - this
  ;  function makes a query
  val hi-res = query-resistance-by-values(cxt, goal-r-hi, precision, search-prec)
  val lo-res = query-resistance-by-values(cxt, goal-r-lo, precision, search-prec)

  ; println("Num Hi: %_  Lo: %_" % [length(hi-res), length(lo-res)])

  for ratio in sort-pairs-by-best-fit(cxt, precision, hi-res, lo-res) first :
    filter-query-results(cxt, ratio, precision)


doc: \<DOC>
Query for the resistor objects and filter-based on physical characteristics
@param cxt The voltage divider's constraints and search parameters
@param ratio Explicit High and Low side resistance values from the current precision series to evaluate.
@param precision Precision series as a percentage value.
<DOC>
defn filter-query-results (
  cxt:VoltageDividerConstraints,
  ratio:Ratio,
  precision:Percentage
  ) -> Maybe<VoltageDividerSolution> :
  println("    - Querying resistors for R1=%_Ω R2=%_Ω" % [high(ratio), low(ratio)])
  val r-his = query-resistors(cxt, high(ratio), precision)
  val r-los = query-resistors(cxt, low(ratio), precision)

  val min-srcs = min-sources(cxt)

  label<Maybe<VoltageDividerSolution>> return:

    if length(r-his) < min-srcs or length(r-los) < min-srcs :
      println("      Ignoring: there must at least %_ resistors of each type" % [min-srcs])
      None()

    val r-hi-cmp = r-his[0]
    val r-lo-cmp = r-los[0]
    val vo-set = study-solution(cxt, r-hi-cmp, r-lo-cmp, temp-range(cxt))
    val vo-valids = to-tuple $ for vo in vo-set seq:
      is-compliant?(cxt, vo)

    val is-valid? = all?({_}, vo-valids)

    if not is-valid? :
      println("      Ignoring: not a solution when taking into account TCRs.")
      defn fmt (ok:True|False, vo:Toleranced):
        match(ok:True):
          "OK"
        else:
          "FAIL (%_ V)" % [vo]

      println("        min-temp: %_"% [fmt(vo-valids[0], vo-set[0])])
      println("        max-temp: %_" % [fmt(vo-valids[1], vo-set[1])])
      None()

    println("      Solved: mpn1=%_, mpn2=%_, v-out=(%,V), current=%_A"
            % [mpn(r-hi-cmp), mpn(r-lo-cmp), vo-set, typ-value(vo-set[0]) / low(ratio)])
    ; TODO - compute the worst case v-out here and use that instead of
    ;  just the first (min temperature) one
    val worst-case-vo = vo-set[0]
    One $ VoltageDividerSolution(r-hi-cmp, r-lo-cmp, worst-case-vo)


doc: \<DOC>
Find the best fit resistance pairs from this series.

@param v-in Input Voltage Range as specified to the solver
@param v-out Desired output voltage range as specified to the solver
@param precision E-Series Precision for these families of resistors
@param hi-res Set of nominal resistance values in ohms for components in this series
@param lo-res Set of nominal resistance values in ohms for components in this series
<DOC>
defn sort-pairs-by-best-fit (
  cxt:VoltageDividerConstraints,
  precision: Percentage,
  hi-res: Tuple<Double>,
  lo-res: Tuple<Double>) -> Tuple<Ratio> :
  qsort{loss, _} $
    for rh in hi-res seq-cat :
      for rl in lo-res seq? :
        val loss? = compute-loss(cxt, rh, rl, precision)
        match(loss?):
          (given:One<Double>): One $ Ratio(rh, rl, value(given))
          (_:None): None()

doc: \<DOC>
Query for Resistance Values within the specified precision range

This is a limited query that only returns distinct resistance values
in the range we are inspecting.

@param cxt Voltage Divider Constraints and Parameters. This provides the
base query settings.
@param goal-r Goal resistance value in ohms
@param r-prec Target Precision family - ie (1 %) or (5 %), etc.
@param min-prec Precision family from which to create a range so we don't
query for just a single value. This is primarily for pragmatic search efficiency

@return Set of resistance values for the components that meet the defined specs.
<DOC>
defn query-resistance-by-values (cxt:VoltageDividerConstraints, goal-r:Double, r-prec:Percentage, min-prec:Percentage) -> Tuple<Double> :
  val R = goal-r +/- min-prec
  ; println("query-by-value: r=%_ prec=%_" % [R, r-prec])
  val j-objs = search-resistors(
    base-query(cxt)
    resistance = R,
    precision = r-prec
    exist! = ExistKeys(tcr_pos = true, tcr_neg = true),
    distinct! = DistinctKey(resistance = true)
  )
  to-tuple $ for j-obj in j-objs seq:
    j-obj as Double

doc: \<DOC>
Query for resistors matching a particular target resistance and precision.
@param cxt Voltage Divider Constraints and Parameters. This provides the
base query settings.
@param target Target Resistance Value for constructing the query.
@param prec Precision series for the resistors that we wish to query for.
@return Set of resistors required by the query - limited to `query-limit(cxt)`. This
returns the full data listing for each resistors so that we can do more analysis.
<DOC>
defn query-resistors (cxt:VoltageDividerConstraints, target: Double, prec:Percentage) -> Tuple<Resistor> :
  val j-objs = search-resistors(
    base-query(cxt)
    resistance = target
    precision = prec
    exist! = ExistKeys(tcr_pos = true, tcr_neg = true),
    limit = query-limit(cxt)
  )
  to-tuple $ for j-obj in j-objs seq:
    parse-component(j-obj as JObject) as Resistor

doc: \<DOC>
Compute the TCR deviations for the temperature extrema
@param r Resistor component object
@param temp Temperature range for evaluating the TCR.
<DOC>
defn compute-tcrs (r:Resistor, temp:Toleranced) -> Tuple<Toleranced|False> :
  to-tuple $ for func in [min-value, max-value] seq:
    compute-tcr-deviation(r, func(temp))

doc: \<DOC>
Compute the voltage divider expected output over a temperature range.
@param cxt Voltage divider constraints

@param r-hi High side divider resistor from query results
@param r-lo Low side divider resistor from query results
@param temp-range Temperature range extrema that we will compute.
@return Tuple of [MinTemp-Vout, MaxTemp-Vout]. These are the extrema points
of the voltage divider output based on `temp-range`
<DOC>
defn study-solution (cxt:VoltageDividerConstraints, r-hi: Resistor, r-lo: Resistor, temp-range:Toleranced) -> Tuple<Toleranced>:
  val lo-drs = compute-tcrs(r-lo, temp-range)
  ; println("Lo-DRS: %_" % [lo-drs])
  val hi-drs = compute-tcrs(r-hi, temp-range)

  val r-lo-val = get-resistance(r-lo)
  val r-hi-val = get-resistance(r-hi)

  to-tuple $ for (lo-dr? in lo-drs, hi-dr? in hi-drs) seq:
    match(lo-dr?, hi-dr?):
      (lo-dr:Toleranced, hi-dr:Toleranced):
        compute-objective(cxt,
            r-hi-val,
            r-lo-val,
            hi-dr,
            lo-dr
          )
      (lo-dr, hi-dr):
        throw $ ValueError("No TCR Data")

